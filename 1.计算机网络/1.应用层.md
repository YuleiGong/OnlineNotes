# 应用层

* [HTTP](#HTTP)
    * [持续连接](#持续连接)
    * [Cookie](#Cookie)
    * [Web缓存器](#Web缓存器)
    * [条件GET方法](#条件Get方法)
    * [HTTPS](#HTTPS)
* [DNS](#DNS)

## HTTP
* HTTP 全称 __超文本传输协议__ ，是一个使用 __TCP__ 协议作为支撑的应用层协议。
#### 持续连接
* HTTP/1.1 默认情况下采用 __持续连接(keep-Alive)__ ，持续连接情况下，服务器在发送响应后保持该TCP连接打开，在相同的客户端和服务器之间，后续的请求和响应都能通过相同的连接传送。
#### Cookie
* HTTP 协议本身是无状态的，可以通过cookie识别用户
* cookie 四个组件:
    * 1. HTTP 响应报文中的一个set-cookie行。
    * 2. HTTP 请求报文中的一个cookie首部行。
    * 3. 客户端的cookie文件，通常是kv结构，通常由浏览器进行管理。
    * 4. Web服务器的后端数据库。
#### Web缓存器
* Web 缓存器也叫代理服务器 __Proxy Server__， web缓存器有自己的存储空间，存储最近请求过的对象副本。一旦浏览器被配置cache地址，会首先请求web缓存器。
* 部署Web缓存器优点:
    * 1. 可以大大减少对客户端的响应，cache通常由ISP购买并安装。
    * 2. 减少一个机构接入链路到因特网的通信流量。

#### 条件GET方法
* 尽管缓存可以减少用户感知到的响应时间，但是缓存引入了一个新的问题。存储在cache中的对象可能是陈旧的。
* HTTP提供了条件GET方法，这个方法使得cache能够确认它的对象是最新的。
    * 1. 请求报文使用了GET方法
    * 2. 请求报文包括了一个If-Modified-Since请求头,记录了最后修改日期。
* cache向服务器发送一个请求确认缓存是否被修改过，如果服务器返回304的状态码(Not Modified)意味着缓存可以继续使用。

#### HTTPS
* 对称加密: 对称加密算法中，加密和解密使用的密钥是相同的。
* 非对称加密 : 非对称加密算法中，加密使用的密钥和解密使用的密钥是不相同的。一把是作为公开的公钥，另一把是作为谁都不能给的私钥。公钥加密的信息，只有私钥才能解密。私钥加密的信息，只有公钥才能解密。实践中，需要使用一对公钥私钥。客户端给服务器发送的时候，用服务器的公钥加密。而服务器给客户端返回消息的时候，使用客户端的公钥加密。保证信息不被泄露。
* 数字证书: 在交换密钥的过程中，为了确保公钥正确，需要使用数字证书认证。 客户端不会从服务器得到一个公钥，而是会得到一个 __证书__，这个证书有个发布机构 __CA__ ，你只要得到这个发布机构 CA 的公钥，去解密服务器网站证书的签名(CA机构会用自己的私钥给服务器的公钥签名)，如果解密成功了，Hash 也对的上，就说明这个公钥没有啥问题。此外，如果你不信任自己的CA公钥，可以使用上层CA机构的公钥验证，层层上报，一直到 __root-CA__ root-CA机构的公钥是默认安装在操作系统里的。
* HTTP工作模式: 
    * 1. 第一次请求，客户端会以以明文传输 TLS 版本信息、加密套件候选列表、压缩算法候选列表等信息。另外，还会有一个随机数，在协商对称密钥的时候使用，服务器收到请求后选择使用的协议版本、加密套件、压缩算法等，还有一个随机数，用于后续的密钥协商。
    * 2. 然后，服务器向客户端发送一个证书，客户端会向CA机构验证证书是否合法。
    * 3. 证书验证合法，客户端从证书中得到服务器公钥，客户端使用加密算法生成pre-master 。并使用服务器的公钥加密pre-master传输到服务器。
    * 4. 至此，双方都有 client-random server-random pre-master , 使用这个key 作为数据传输的 __对称密钥__。

## DNS

