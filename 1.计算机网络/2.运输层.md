# 运输层

* [UDP](#UDP)
    * [特性](#特性)
    * [校验和](#校验和)
* [TCP](#TCP)
    * [三次握手](#三次握手)
        * [为什么需要三次握手](#为什么需要三次握手)
        * [为什么初始isn序号是不相同的](#为什么初始isn序号是不相同的)
    * [四次挥手](#四次挥手)
        * [为什么需要挥手四次](#为什么需要挥手四次)
        * [为什么需要TIME_WAIT](#为什么需要TIME_WAIT)
        * [TIME_WAIT过多的危害](#TIME_WAIT过多的危害)
    * [重传机制](#重传机制)
        * [超时重传](#超时重传)
        * [快速重传](#快速重传)
    * [滑动窗口](#滑动窗口)
        * [发送方窗口](#发送方窗口)
        * [接收方窗口](#接收方窗口)
    * [流量控制](#流量控制)
    * [拥塞控制](#拥塞控制)


## UDP
### 特性
* 1. __无连接__ : UDP不需要握手，不需要在客户端和服务器维护连接和交互状态。
* 2. UDP 不保证数据不丢失，不保证按序到达。
* 3. UDP基于 __数据报__ 发送。

### 校验和
* UDP 提供了差错检测功能。通过 __校验和(checksum)__ 可以确定UDP报文段从源到达目的地时，比特是否发生了改变。
* 虽然UDP提供了差错检测，但对差错恢复无能为力。


## TCP
* TCP 是 __面向连接__ 的，在两个进程发送数据之前，必须先建立连接(__握手__)，连接双方都会保持各自的状态。

### 报文段结构
* __源端口号__ 和 __目的端口号__ 用于确定数据交付，发送个哪个应用。
* __校验和__ 提供了差错检测。
* __序号和确认序号__ 用来实现可靠数据传输服务。
* __标志字段__ 用于控制TCP的状态位。
* __接收窗口__ 用于流量控制。

### 三次握手
* 1. 客户端首先向服务器发送一个SYN=1的 __SYN报文段__。客户段还会随机选择一个初始序号 SYN=1，seq=client_isn。
* 2. 服务端收到SYN报文段后，会为TCP连接分配缓冲区和变量，TCP连接处于半开状态。同时服务端向客户端发送 __SYNACK报文段__。 SYN=1，ACK=1，ack=client_isn+1(确认号字段)，seq=server_isn(初始序号)。
* 3. 客户端收到 __SYNACK报文段__ 后，会给该TCP连接分配缓存和变量，同时向服务器发送一个允许连接报文段的确认。 SYN=0,ACK=1，ack=server_isn+1，seq=client_isn+1。可以在确认报文负载中携带数据信息。
#### 为什么需要三次握手
* 1. 避免历史连接初始化。因为网络阻塞的原因，在连接建立阶段，一个旧的 __SYN报文段__ 比一个新的 __SYN报文段__ 先到达服务端，服务端放回 __SYNACK报文段__。客户端可以根据ack序号来判断这是一个历史连接，在第三次握手时，发送一个 __RST__ 报文，表示终止这一次连接，同时避免了资源浪费。
* 2. 同步双方的初始序列号。 协议中的初始序号，使得接收方可以去除重复数据，并保证按序接收。还可以标识发送出去的数据包，哪些是对端已经接收成功的。使用三次握手，保证了双方的序列号可靠的同步。如果使用二次握手，就不能保证客户端成功同步了服务端的序列号。

#### 为什么初始isn序号是不相同的
* 如果一个已经失效的连接被重用，但是该旧连接的历史报文还残留在网络中，如果序列号相同，那么就无法分辨出该报文是不是历史报文，如果历史报文被新的连接接收了，则会产生数据错乱。所以，每次建立连接前都要初始化一个序列号主要是为了通信双方能够根据序号将不属于本连接的报文段丢弃。

### 四次挥手
* 1. 客户端关闭连接，会发送一个FIN=1的 __FIN报文__，之后，客户端进入 __FIN_WAIT_1__ 状态。
* 2. 服务端收到 __FIN报文__ 后，就向客户端发送 __ACK应答报文__，接着服务端进入 __CLOSED_WAIT__ 状态。
* 3. 客户端收到服务端的 ACK应答报文后，之后进入 __FIN_WAIT_2__ 状态。
* 4. 等待服务端处理完数据后，也向客户端发送 __FIN报文__，之后服务端进入 __LAST_ACK__ 状态。
* 5. 客户端收到服务端的 __FIN报文__ 后，回一个 ACK应答报文，之后进入 __TIME_WAIT__ 状态
* 6. 服务器收到了 ACK应答报文后，就进入了 __CLOSED__ 状态，至此服务端已经完成连接的关闭。
* 7. 客户端在经过 2MSL 一段时间后，自动进入 __CLOSED__ 状态，至此客户端也完成连接的关闭。

***每个方向都需要一个FIN ACK， 因此被称为四次挥手*** 
#### 为什么需要挥手四次
* 关闭连接时，客户端向服务端发送 __FIN__ 时，仅仅表示客户端不再发送数据了但是还能接收数据。 
* 服务器收到客户端的 FIN 报文时，先回一个 ACK 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 FIN 报文给客户端来表示同意现在关闭连接。

***从上面过程可知，服务端通常需要等待完成数据的发送和处理，所以服务端的 ACK 和 FIN 一般都会分开发 送，从而比三次握手导致多了一次。***

#### 为什么需要TIME_WAIT
* 1. __防止旧连接的数据包__: 假设在服务端关闭连接之前，发送的数据包被网络延迟了，这时候，连接已经被关闭。新的TCP连接被复用，恰好被延迟的数据包到达客户端，这就会导致数据错乱。这个时候，time_wait 2ML，足以让两个方向上的数据包在网络中自然消失，确保正确。
* 2. __保证连接正确关闭__: 假设TIME_WAIT 时间过短，不能确保最后一个ACK按时到达，客户端就先关闭了连接，服务端就会一直处于LAST_ACK 状态。当客户端再次发起建立连接的 SYN 请求报文后，服务端会发送 RST 报文给客户端，连接建立的过程就会被终止。
#### TIME_WAIT过多的危害
* 1. 内存资源的占用。
* 2. 端口不够用，没法新建新的TCP连接。

### 重传机制
* TCP 实现可靠传输的方式之一，是通过序列号与确认应答。当发送端的数据到达接收主机时，接收端主机会返回一个确认应答消息，表示已收到消息。
#### 超时重传
* 数据包丢失重传, ACK应答丢失重传
* __超时时间RTO__: RTT 就是数据从网络一端传送到另一端所需的时间,超时时间应该略大于RTT。
    * 1. 当超时时间 RTO 较大时，重发就慢，导致网络利用率低。
    * 2. 当超时时间 RTO 较小时，会导致没有丢的包就重发，增加网络拥塞，导致更多的超时。
* 如果超时重发的数据，再次超时的时候，TCP 的策略是超时间隔加倍。两次超时，就说明网络环境差，不宜频繁反复发送。
#### 快速重传
* 使用快速重传，可以避免长时间的等待。客户端在收到三个相同的ACK(__冗余ACK__)报文后，会立即重传丢失的报文段。
* __SACK__ : 选择确认，这种方式需要在 TCP 头部「选项」字段里加一个 SACK 的东⻄，它可以将缓存的数据包序号发送给发送方，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以只重传丢失的数据。

### 滑动窗口
* 如果TCP每发送一次数据，都要进行一次确认，再发送下一个数据包，效率就很低下，通过设置 __窗口__，可以无需等待确认应答，继续发送。
* 连续发送 三个数据包，如果第二个数据包的ack2丢失， ack到达发送方，可以认为三个数据包都全部到达。
* __接收窗口__ : 这个TCP字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。

#### 发送方窗口
* TODO 补图

#### 接收方窗口
* TODO 补图


### 流量控制
* TCP 提供一种机制可以让发送方的__发送速率__和接收方__接收速率__得到匹配，流量控制因此是一个__速度匹配__服务，通过让 __发送方__ 维护一个称为 __接收窗口__ 的变量来提供流量控制。
* TODO 补图 自顶向下 p165
* __窗口探测__: 当接收方窗口为0，发生窗口关闭时，发送方停止发送。当接收方处理完成后，会向发送方通告一个窗口非 0 的 ACK 报文，如果这个通告窗口 的 ACK 报文在网络中丢失了，会造成死锁现象。为了解决这个问题，TCP 为每个连接设有一个持续定时器，只要 TCP 连接一方收到对方的零窗口通知，就启动计时器。如果持续计时器超时，就会发送 __窗口探测__ ，而对方在确认这个探测报文时，给出自己现在的接收窗口大小。

### 拥塞控制



